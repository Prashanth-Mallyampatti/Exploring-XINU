# Exploring-XINU
Getting acquainted with XINU by performing various well known tasks

XINU is a small Unix-like operating system originally developed by Douglas Comer for instructional purposes at Purdue University. It is small enough so that we can understand it entirely within one semester. We will re-implement or improve some apsects of XINU.

Step 0: Installing QEMU

    Following the instructions at the https://pdos.csail.mit.edu/6.828/2018/tools.html site to install QEMU.
I have tested this on Ubuntu 14.04, and it works. However, the QEMU from "apt-get install qemu" has problems. I have also tried Ubuntu 18.04, but it does not work well with the main problem that the XINU tarball fails to compile properly.

After you install QEMU, you need to change your PATH environment accordingly so that the later "make run" and "make debug" commands can find the binary.

If this is not enough for you to setup a local QEMU environment, I would suggest you just use the VCL environment.

Step 1: Setting environment variables:

    Get access to a customized VCL image -- XINU+QEMU (CSC501) -- through the VCL facility

Step 2: Untar the XINU source files as follows:

    Change to a working directory you would like to use for this project, preferable using 

    /afs/unity.ncsu.edu/users/m/myid/this/is/my/project/dir
    cd /afs/unity.ncsu.edu/users/m/myid/this/is/my/project/dir

    Untar the XINU source by typing the following:
    wget -U firefox https://people.engr.ncsu.edu/gjin2/Classes/501/Fall2018/assignments/PA0/csc501-lab0.tgz
    tar xzvf csc501-lab0.tgz

    In your working directory, you will now have a directory named csc501-lab0. The subdirectories under this directory contain source code, header files, etc, for XINU.

NOTE: the tar file name may be different from the above depending on the project you are working on. Please refer to the project handouts for the location of the tar file for the current project.

If you have a way to get rid of "-U firefox", let me know.

    LD = /usr/bin/gcc

Step 3: Building XINU

    To compile the XINU kernel which will be downloaded and run on the backend machines, run "make" in the compile directory as follows:

    cd csc501-lab0/compile
    make depend
    make

This creates an OS image called 'xinu.elf'.
If you use the local QEMU environment, you may need to change two lines in the Makefile:

    LD      =       /usr/bin/ld
    to
    LD      =       /usr/bin/gcc
    and
    $(LD) -m elf_i386 -dn -Ttext 0x10000 -e start ${XOBJ} ${OBJ} ${LIB}/libxc.a \
    to
	  $(LD) -m32 -dn -Ttext 0x10000 -e start ${XOBJ} ${OBJ} ${LIB}/libxc.a \
  
Step 4: Running and debugging XINU

    The XINU image runs on the QEMU emulator machines. To boot up the image, type:
    make run

XINU should start running and print a message "Hello World, Xinu lives."
    
    Typing "Ctrl-a" then "c" will always bring you to "(qemu)" prompt. From there, you can quit by typing q.

To debug XINU, run the image in the debug mode by:
    
    make debug

Then execute GDB in another ssh session:

    gdb xinu.elf
In the (gdb) console, connect to the remote server by:

target remote localhost:1234

You can use many debugging features provided by GDB, e.g., adding a break point at the main function:

    b main

To run to the next breakpoint, type:

    c

The detailed document for GDB can be found https://sourceware.org/gdb/

Several XINU functions were implemented that perform the following tasks:

1) long zfunction(long param)
      
      Clearing the 9th to 17th bits, counting from right and starting with 0, shift the parameter param by 8 bits to the right, and then fill the left most bits with 1. For example, the input parameter 0xaabbccdd should generate a return value of 0xffaab800. You can assume that the size of long is 4 bytes. The code for this function is  entirely written in x86 assembly (not use asm(???)). To investigate the assembly code generated by the compiler, the tool objdump -d <___.o> is used to disassemble an object file. The object files reside in the /compile directory within the main Xinu directory. You can also see some of the *.S files in the /sys directory for reference.

2) void printsegaddress()

      Printing the addresses and their contents indicating the end of the text, data, and BSS segments of the current process. Refered to the manual page for "etext". Also printing the 4-byte contents (in hexadecimal) preceding and after those addresses. This function is be written in C.

3) void printtos()

      Printing the address and their contents of the top of the run-time stack for whichever process I am currently in, right before and right after getting into the printos() function call. In addition, printing the address and their contents of upto four stack locations below the top of the stack (the four or fewer items that have been the most recently pushed, if any). Remember that stack elements are 32 bits wide, and be careful to perform pointer arithmetic correctly. Also note that there are local variables and arguments on the stack, among other things. See the hints given for #4 below, especially on stacktrace.c and proc.h.

4) void printprocstks(int priority)

      For each existing process with larger priority than the parameter, printed the stack base, stack size, stacklimit, and stack pointer. Also, for each process, included the process name, the process id and the process priority. Looked into proc.h in the h/ directory for reference. Note the proctab[] array that holds all processes. Also, note that the pesp member of the pentry structure holds the saved stack pointer. Therefore, the currently executing process has a stack pointer that is different from the value of this variable. In order to help you get the stack pointer of the currently executing process, carefully study the stacktrace.c file in the sys/ directory. The register %esp holds the current stack pointer.

5) void printsyscallsummary()

      Printed the summary of the system calls which have been invoked for each process. This task is loosely based on the functionality of LTTng. There are 43 system calls declared. kernel.h in the h/ directory has all declared system calls. However, only 27 system calls are implemented in this XINU version. The implementation of these 27 system calls are in the sys/ directory. Printed the frequency (how many times each system call type is invoked) and the average execution time (how long it takes to execute each system call type in average) of these 27 system calls for each process. In order to do this, modified the implementation of these 27 types of system calls to trace them whenever they are invoked. To measure the time, XINU provides a global variable named ctr1000 to track the time (in milliseconds) passed by since the system starts. sys/clkinit.c and sys/clkint.S are the locations where time function in defined. 

6) void syscallsummary_start(): 

      To start tracing the system calls. All the system calls are invoked after calling this function (and before calling syscallsummary_stop()) will be presented in the system call summary.
        
7) void syscallsummary_stop(): 
      
      To stop tracing the system calls. 
        
In other words, these two functions determine the duration in which the system calls are traced. 

syscalls.txt lists all the system calls you will need to trace, and test.c demonstrates the usage of the functions.

Implemented this lab as a set of functions that can be called from main(). Each function resides in a separate file in the sys directory, and should be incorporated into the Makefile. The files are named after the functions are implementing with C files having the .c extension and the assembly files having the .S extension. For example, the file that will hold void printsegaddress() is named printsegaddress.c; and the file that will hold long zfunction(long param) is named zfunction.S. Added syscallsummary_start, syscallsummary_stop functions in the same file as printsyscallsummary function and named it as printsyscallsummary.c .  Note: as you create new files, you may need to update the Makefile (located in the compile/directory) to configure it to compile your files correctly. Just look at what is done for the existing files (e.g., main.c).
